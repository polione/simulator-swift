\section{Pipeline Instance}\label{sec:instance}
%Given a set of candidate services, a
A \pipelineInstance $\iChartFunction$ instantiates a \pipelineTemplate \tChartFunction by composing services in the instance according to data protection and functional annotations in the template.  It is formally defined as follows.

\begin{definition}[Pipeline Instance]\label{def:instance}
  Let \tChartFunction be a pipeline template, a pipeline Instance $\iChartFunction$ is an isomorphic directed acyclic graph where:
  \begin{enumerate*}[label=\textit{\roman*})]
    \item $v'_r$$=$$v_r$;
    \item for each vertex $\vi{}\in\V_{\timesOperator}\cup\V_{\plusOperator}$, there exists a corresponding vertex $\vii{}\in\Vp_{\timesOperator}\cup\Vp_{\plusOperator}$;
    \item for each $\vi{i}$$\in$$\V_S$ annotated with policy \P{i}, there exists a corresponding vertex \vii{i}$\in$$\Vp_S$ instantiated with a service \sii{i}, such that:
  \end{enumerate*}
  \begin{enumerate}[label=\arabic*)]
    \item $s'_i$ satisfies data protection annotation \myLambda(\vi{i}) in \tChartFunction;
    \item $s'_i$ satisfies functional annotation \myGamma(\vi{i}) in \tChartFunction.
  \end{enumerate}
\end{definition}

Condition 1 requires that each selected service \sii{i} satisfies the policy requirements \P{i} of the corresponding vertex \vi{i} in the \pipelineTemplate, whereas Condition 2 is needed to preserve the process functionality, as it simply states that each service \sii{i} must satisfy the functional requirements \F{i} of the corresponding vertex \vi{i} in the \pipelineTemplate.

We then define a \emph{pipeline instantiation} function that takes as input a \pipelineTemplate \tChartFunction and a set $S^c$ of candidate services, with a specific set of services $S^c_{i}$ for each vertex \vi{i}$\in$$\V_S$, and returns as output a \pipelineInstance \iChartFunction. Recall from Section~\ref{sec:funcannotation} that all candidate services meet the functional annotation in the template, meaning that Condition 2 in Definition~\ref{def:instance} is satisfied for all candidate services.

    The \pipelineInstance  is generated by traversing the \pipelineTemplate with a breadth-first search algorithm, starting from the root vertex \vi{r}.
    Then, for each vertex $v\in\Vplus\bigcup\Vtimes$ in the pipeline template, the corresponding vertex $v'\in\Vpplus\bigcup\Vptimes$ is generated.
    Finally, for each vertex \vi{i}$\in$$\V_S$, a two-step approach is applied as follows.

  \begin{enumerate}

    \item \textit{Filtering Algorithm} -- The filtering algorithm checks if the profile \profile$_j$ of each candidate service $\si{j}$$\in$$S^c_{i}$ satisfies the policies $p_k$$\in$\P{i} corresponding to \myLambda(\vi{i}). If \profile$_j$ satisfies at least one policy,  service $\si{j}$ is compatible, otherwise it is discarded. The filtering algorithm finally returns a subset $S'_{i}$$\subseteq$$S^c_{i}$ of compatible services for each vertex \vi{i}$\in$$\V_S$.
    \item \textit{Selection Algorithm} -- The selection algorithm selects one service $s'_i$ for each set $S'_{i}$ of compatible services and instantiates the corresponding vertex $\vii{i}$$\in$$\Vp$ with it. There are many ways of choosing $s'_i$, we present our approach based on the minimization of quality loss in Section \ref{sec:metrics}.
  \end{enumerate}

  When all vertices $\vi{i}$$\in$$V$ have been visited, the \pipelineInstance G' is finalized, with a service instance $s'_i$ for each \vii{i}$\in$\Vp. Vertex \vii{i} is still annotated with policies $p_k$$\in$\P{i} according to \myLambda, because policies in \P{i} are evaluated and enforced only when the pipeline instance is triggered, before any service is executed. In case policy evaluation returns \emph{true}, data transformation \TP$\in$\P{i} is applied, otherwise a default transformation that removes all data is applied.

\begin{figure}[ht!]
  \centering
  \newcommand{\function}{$\instanceChartAnnotation{}$}
  \begin{tikzpicture}[scale=0.7]
    % Nodes
    \node[draw, circle, fill,text=white,minimum size=1 ] (sr) at (0,0) {};

    % \node[draw, circle] (node2) at (1,0) {$\s{1}$};
    \node[draw, circle, plus,minimum size=1.5em] (plus) at (1.5,0) {};

    \node[draw, circle] (s2) at (3.5,-2) {$\sii{1}$};
    \node[draw, circle] (s3) at (3.5,0) {$\sii{2}$};
    \node[draw, circle] (s1) at (3.5,2) {$\sii{3}$};

    \node[draw, circle] (s4) at (5,0) {$\sii{4}$};
    \node[draw, circle] (s5) at (6.5,0) {$\sii{5}$};

    \node[draw, circle] (s6) at (8.0,0) {$\sii{6}$};
    \node[draw, circle] (s7) at (9.5,0) {$\sii{7}$};
    % Text on top
    % \node[above] at (sr.north)  {\function{}};
    \node[above] at (s1.north)  {\function{}};

    \node[above] at (s2.north)  {\function{}};
    \node[above] at (s3.north)  {\function{}};
    \node[above] at (s4.north)  {\function{}};
    \node[above] at (s5.north)  {\function{}};
    % \node[above] at (s6.north)  {\function{}};
    \node[above] at (s6.north)  {\function{}};
    \node[above] at (s7.north)  {\function{}};
    % Connection

    % \draw[->] (node2) -- (node3);
    \draw[->] (sr) -- (plus);
    \draw[->] (plus) -- (s1);
    \draw[->] (plus) -- (s2);
    \draw[->] (plus) -- (s3);

    \draw[->] (s1) -- (s4);
    \draw[->] (s2) -- (s4);
    \draw[->] (s3) -- (s4);
    % \draw[->] (node6) -- (node65);
    % \draw[->] (node65) -- (node7);3
    \draw[->] (s4) -- (s5);
    \draw[->] (s5) -- (s6);
    % \draw[->] (cross) -- (s5);
    % \draw[->] (cross) -- (s6);
    % \draw[->] (s5) -- (s7);
    % \draw[->] (s6) -- (s7);
    \draw[->] (s6) -- (s7);

  \end{tikzpicture}
  \caption{Service composition instance}
  \label{fig:service_composition_instance}
\end{figure}

\subsection{Example}\label{sec:example} TBD (mettere un esempio in cui non sia stato scelto l'ottimo che invece cercheremo e metteremo come esempio nella prossima sezione)

% \subsection{Pipeline Instance Definition}\label{sec:instancedefinition}
% The goal of our approach is to generate an instance of the \pipelineTemplate starting from the \pipelineTemplate in Section~\ref{sec:template}. In the following, we first define the pipeline instance and the corresponding pipeline instantiation process (Section \ref{sec:instancedefinition}). We then prove that the pipeline instantiation process is NP-hard (Section \ref{sec:funcannotation}).

% \subsection{Pipeline Instance Definition}\label{sec:instancedefinition}
% A \pipelineInstance $\iChartFunction$ is a ready-to-be-executed pipeline, which instantiates a \pipelineTemplate \tChartFunction \chia{ selecting the services} according to its data protection and functional annotations. We formally define \tChartFunction as follows.

%     \begin{definition}[Pipeline Instance]\label{def:instance}
%       Let \tChartFunction be a Pipeline Template, a Pipeline Instance $\iChartFunction$ is a directed acyclic graph where:
%       \begin{enumerate*}[label=\textit{\roman*})]
%         \item $s_r$$=$$s'_r$;
%         \item for each vertex $\vi{}\in\V_{\timesOperator}\cup\V_{\plusOperator}$ it exists a corresponding vertex $\vii{}\in\Vp_{\timesOperator}\cup\Vp_{\plusOperator}$;
%         \item for each $\vi{i}$$\in$$\V_S$ annotated with policy \P{i} it exists a corresponding \vii{i}$\in$$\Vp_S$ instantiated with a service instance \sii{i};
%       \end{enumerate*}
%       and such that the following conditions hold:
%       \begin{enumerate}[label=\arabic*)]
%         \item $s'_i$ satisfies data protection annotation \myLambda(\vi{i}) in \tChartFunction;
%         \item $s'_i$ satisfies functional annotation \myGamma(\vi{i}) in \tChartFunction.
%       \end{enumerate}
%     \end{definition}

% Condition 1 states that each service \sii{i} must satisfy the policy requirements \P{i} of the corresponding vertex \vi{i} in the \pipelineTemplate.
%     Condition 2 is needed to preserve the process functionality, as it simply states that each service \sii{i} must satisfy the functional requirements \F{i} of the corresponding vertex \vi{i} in the \pipelineTemplate.

%     We recall that Condition 2 is satisfied for all candidate services (see Section~\ref{sec:funcannotation}) and therefore concentrate on Condition 1 in the following.

% We then define a \emph{Pipeline Instantiation Process} as a function that takes as input a \pipelineTemplate \tChartFunction and a set $S^c$ of candidate services, one for each vertex \vi{i}$\in$\V,\marginpar{ \chia{ $\V_S$?}} and returns as output a \pipelineInstance \iChartFunction in Definition~\ref{def:instance}.
%     %In \iChartFunction, every invocations \vii{i}$\in$$V'_S$ contains a service instance, and every branching $v\in\Vplus\bigcup\Vtimes$ in the template is maintained as is.
%  \chia{ The objective of the Pipeline Instantiation Process is to return a Pipeline Instance that minimizes the quantity of information lost, and maximizes the level of data protection and data sharing, not for the selection of a single service, but in the overall. To this aim, the  \pipelineTemplate is traversed with a breadth-first search algorithm and for each vertex \vi{i}$\in$$\V_S$, a two-step selection approach is applied as follows.}

% %Ovviamente non è sufficiente scegliere il best service per ogni vertice, ma diventa un problema complesso dove si devono calcolare/valutare tutte le possibili combinazioni dei servizi disponibili, tra le quali scegliere la migliore.

%     The \pipelineInstance  is generated by traversing the \pipelineTemplate with a breadth-first search algorithm, starting from the root vertex \vi{r}.
%     Then, for each vertex $v\in\Vplus\bigcup\Vtimes$ in the pipeline template, the corresponding vertex $v'\in\Vpplus\bigcup\Vptimes$ is generated.
%     Finally, for each vertex \vi{i}$\in$$\V_S$, a two-step selection approach is applied as follows.

% \subsection{Pipeline Instance - VECCHIO PARAGRAFO}\label{sec:instance}
% %The goal of our approach is to generate \pipelineInstance starting from the \pipelineTemplate in Section~\ref{sec:template}.
% A \pipelineInstance $\iChartFunction$ instantiates a \pipelineTemplate \tChartFunction by selecting the component services according to its data protection and functional annotations. We formally define \tChartFunction as follows.

%     \begin{definition}[Pipeline Instance]\label{def:instance}
%       Let \tChartFunction be a pipeline template, a pipeline Instance $\iChartFunction$ is a directed acyclic graph where:
%       \begin{enumerate*}[label=\textit{\roman*})]
%         \item $s_r$$=$$s'_r$;
%         \item for each vertex $\vi{}\in\V_{\timesOperator}\cup\V_{\plusOperator}$ it exists a corresponding vertex $\vii{}\in\Vp_{\timesOperator}\cup\Vp_{\plusOperator}$;
%         \item for each $\vi{i}$$\in$$\V_S$ annotated with policy \P{i} it exists a corresponding \vii{i}$\in$$\Vp_S$ instantiated with a service instance \sii{i};
%       \end{enumerate*}
%       and such that the following conditions hold:
%       \begin{enumerate}[label=\arabic*)]
%         \item $s'_i$ satisfies data protection annotation \myLambda(\vi{i}) in \tChartFunction;
%         \item $s'_i$ satisfies functional annotation \myGamma(\vi{i}) in \tChartFunction.
%       \end{enumerate}
%     \end{definition}

% Condition 1 states that each service \sii{i} must satisfy the policy requirements \P{i} of the corresponding vertex \vi{i} in the \pipelineTemplate.
% Condition 2 is needed to preserve the process functionality, as it simply states that each service \sii{i} must satisfy the functional requirements \F{i} of the corresponding vertex \vi{i} in the \pipelineTemplate. We recall that Condition 1 is satisfied for all candidate services (see Section~\ref{sec:funcannotation}) and therefore concentrate on Condition 2 in the following.

%     We then define a \emph{pipeline instantiation} function that takes as input a \pipelineTemplate \tChartFunction and a set $S^c$ of candidate services, one for each vertex \vi{i}$\in$$\V_S$, and returns as output a \pipelineInstance \iChartFunction in Definition~\ref{def:instance}.
%        %In \iChartFunction, every invocations \vii{i}$\in$$V'_S$ contains a service instance, and every branching $v\in\Vplus\bigcup\Vtimes$ in the template is maintained as is.
%     %\chia{ The objective of the Pipeline Instantiation Process is to return a Pipeline Instance that minimizes the quantity of information lost, and maximizes the level of data protection and data sharing, not for the selection of a single service, but in the overall. To this aim, the  \pipelineTemplate is traversed with a breadth-first search algorithm and for each vertex \vi{i}$\in$$\V_S$, a two-step selection approach is applied as follows.}
%   %
%   % %Ovviamente non è sufficiente scegliere il best service per ogni vertice, ma diventa un problema complesso dove si devono calcolare/valutare tutte le possibili combinazioni dei servizi disponibili, tra le quali scegliere la migliore.
%      %
%     The \pipelineInstance  is generated by traversing the \pipelineTemplate with a breadth-first search algorithm, starting from the root vertex \vi{r}.
%     Then, for each vertex $v\in\Vplus\bigcup\Vtimes$ in the pipeline template, the corresponding vertex $v'\in\Vpplus\bigcup\Vptimes$ is generated.
%     Finally, for each vertex \vi{i}$\in$$\V_S$, a two-step selection approach is applied as follows.

%   \begin{itemize}

%     \item \textit{Filtering Algorithm} -- As already discussed in Section~\ref{sec:templatedefinition}, the filtering algorithm retrieves a set of candidate services $S^c$ and matches them one-by-one against data protection requirements \myLambda(\vi{i}). In particular, the profile of each candidate service \si{j} is matched against policies $p_k$$\in$\P{i} corresponding to \myLambda(\vi{i}). Filtering algorithm returns as output the set of compatible services that match the policy.

%     Formally, let us consider a set $S^c$ of candidate services \si{j}, each one having a profile as a set of attributes in the form (\emph{name}, \emph{value}). The filtering algorithm is executed for each \si{j}; it is successful if \si{j}'s profile satisfies at least one policy $p_k$$\in$\P{i}; otherwise, \si{j} is discarded and not considered for selection. The filtering algorithm finally returns a subset $S'\subseteq S^c$ of compatible services, among which the service instance is selected.

%     \item \textit{Selection Algorithm} -- Upon retrieving a set $S'$ of compatible services \si{j}, a service $s'_i$$\in$$S'$ is then selected and integrated in $\vii{i}\in \Vp$. There are many ways of choosing $s'_i$, we present our approach based on quality loss in Section \ref{sec:metrics}.
%     %\item \textit{Selection Algorithm} -- Upon retrieving a set $S'$ of compatible services \si{j}, it produces a ranking of these services according to some metrics that evaluates the quality loss introduced by each service when integrated in the pipeline instance. More details about the metrics are provided in Section \ref{sec:metrics}. The best service $s'_i$ is then selected and integrated in $\vii{i}\in \Vp$. There are many ways of choosing relevant metrics, we present those used in this article in Section \ref{sec:metrics}.
%   \end{itemize}

%   When all vertices $\vi{i}\in V$ have been visited, a \pipelineInstance G' is generated, where each \vii{i}$\in$\Vp contains a service instance $s'_i$. We note that each vertex \vii{i} is annotated with policies $p_k$$\in$\P{i} according to \myLambda. When pipeline instance is triggered, before any services can be executed, policies in \P{i} are evaluated and enforced. In case policy evaluation returns \emph{true}, data transformation \TP$\in$\P{i} is applied, otherwise a default transformation that removes all data is applied.

% \begin{figure}[ht!]
%   \centering
%   \newcommand{\function}{$\instanceChartAnnotation{}$}
%   \begin{tikzpicture}[scale=0.7]
%     % Nodes
%     \node[draw, circle] (sr) at (0,0) {$\vi{r}$};
%     % \node[draw, circle] (node2) at (1,0) {$\s{1}$};
%     \node[draw, circle, plus,minimum size=1.5em] (plus) at (1.5,0) {};
%     \node[draw, circle] (s1) at (3,1.7) {$\sii{1}$};
%     \node[draw, circle] (s2) at (3,-1.7) {$\sii{2}$};
%     \node[draw, circle] (s3) at (3,0) {$\sii{3}$};


%     \node[draw, circle] (s4) at (4.5,0) {$\sii{4}$};
%     \node[draw, circle, cross,minimum size=1.5em] (cross) at (6,0) {};
%     \node[draw, circle] (s5) at (7.5,1.2) {$\sii{5}$};
%     \node[draw, circle] (s6) at (7.5,-1.2) {$\sii{6}$};

%     \node[draw, circle] (s7) at (9,0) {$\sii{7}$};
%     \node[draw, circle] (s8) at (10.5,0) {$\sii{8}$};
%     % Text on top
%     \node[above] at (sr.north)  {\function{}};
%     \node[above] at (s1.north)  {\function{}};

%     \node[above] at (s2.north)  {\function{}};
%     \node[above] at (s3.north)  {\function{}};
%     \node[above] at (s4.north)  {\function{}};
%     \node[above] at (s5.north)  {\function{}};
%     \node[above] at (s6.north)  {\function{}};
%     \node[above] at (s7.north)  {\function{}};
%     \node[above] at (s8.north)  {\function{}};
%     % Connection

%     % \draw[->] (node2) -- (node3);
%     \draw[->] (sr) -- (plus);
%     \draw[->] (plus) -- (s1);
%     \draw[->] (plus) -- (s2);
%     \draw[->] (plus) -- (s3);

%     \draw[->] (s1) -- (s4);
%     \draw[->] (s2) -- (s4);
%     \draw[->] (s3) -- (s4);
%     % \draw[->] (node6) -- (node65);
%     % \draw[->] (node65) -- (node7);3
%     \draw[->] (s4) -- (cross);
%     \draw[->] (cross) -- (s5);
%     \draw[->] (cross) -- (s6);
%     \draw[->] (s5) -- (s7);
%     \draw[->] (s6) -- (s7);
%     \draw[->] (s7) -- (s8);

%   \end{tikzpicture}
%   \caption{Service composition instance}
%   \label{fig:service_composition_instance}
% \end{figure}


% % \subsection{Pipeline Instance Definition}\label{sec:instancedefinition}
%   % The goal of our approach is to generate an instance of the \pipelineTemplate starting from the \pipelineTemplate in Section~\ref{sec:template}. In the following, we first define the pipeline instance and the corresponding pipeline instantiation process (Section \ref{sec:instancedefinition}). We then prove that the pipeline instantiation process is NP-hard (Section \ref{sec:funcannotation}).

%   % \subsection{Pipeline Instance Definition}\label{sec:instancedefinition}
%   % A \pipelineInstance $\iChartFunction$ is a ready-to-be-executed pipeline, which instantiates a \pipelineTemplate \tChartFunction \chia{ selecting the services} according to its data protection and functional annotations. We formally define \tChartFunction as follows.

%   %     \begin{definition}[Pipeline Instance]\label{def:instance}
%   %       Let \tChartFunction be a Pipeline Template, a Pipeline Instance $\iChartFunction$ is a directed acyclic graph where:
%   %       \begin{enumerate*}[label=\textit{\roman*})]
%   %         \item $s_r$$=$$s'_r$;
%   %         \item for each vertex $\vi{}\in\V_{\timesOperator}\cup\V_{\plusOperator}$ it exists a corresponding vertex $\vii{}\in\Vp_{\timesOperator}\cup\Vp_{\plusOperator}$;
%   %         \item for each $\vi{i}$$\in$$\V_S$ annotated with policy \P{i} it exists a corresponding \vii{i}$\in$$\Vp_S$ instantiated with a service instance \sii{i};
%   %       \end{enumerate*}
%   %       and such that the following conditions hold:
%   %       \begin{enumerate}[label=\arabic*)]
%   %         \item $s'_i$ satisfies data protection annotation \myLambda(\vi{i}) in \tChartFunction;
%   %         \item $s'_i$ satisfies functional annotation \myGamma(\vi{i}) in \tChartFunction.
%   %       \end{enumerate}
%   %     \end{definition}

%   % Condition 1 states that each service \sii{i} must satisfy the policy requirements \P{i} of the corresponding vertex \vi{i} in the \pipelineTemplate.
%   %     Condition 2 is needed to preserve the process functionality, as it simply states that each service \sii{i} must satisfy the functional requirements \F{i} of the corresponding vertex \vi{i} in the \pipelineTemplate.

%   %     We recall that Condition 2 is satisfied for all candidate services (see Section~\ref{sec:funcannotation}) and therefore concentrate on Condition 1 in the following.

%   % We then define a \emph{Pipeline Instantiation Process} as a function that takes as input a \pipelineTemplate \tChartFunction and a set $S^c$ of candidate services, one for each vertex \vi{i}$\in$\V,\marginpar{ \chia{ $\V_S$?}} and returns as output a \pipelineInstance \iChartFunction in Definition~\ref{def:instance}.
%   %     %In \iChartFunction, every invocations \vii{i}$\in$$V'_S$ contains a service instance, and every branching $v\in\Vplus\bigcup\Vtimes$ in the template is maintained as is.
%   %  \chia{ The objective of the Pipeline Instantiation Process is to return a Pipeline Instance that minimizes the quantity of information lost, and maximizes the level of data protection and data sharing, not for the selection of a single service, but in the overall. To this aim, the  \pipelineTemplate is traversed with a breadth-first search algorithm and for each vertex \vi{i}$\in$$\V_S$, a two-step selection approach is applied as follows.}

%   % %Ovviamente non è sufficiente scegliere il best service per ogni vertice, ma diventa un problema complesso dove si devono calcolare/valutare tutte le possibili combinazioni dei servizi disponibili, tra le quali scegliere la migliore.

%   %     The \pipelineInstance  is generated by traversing the \pipelineTemplate with a breadth-first search algorithm, starting from the root vertex \vi{r}.
%   %     Then, for each vertex $v\in\Vplus\bigcup\Vtimes$ in the pipeline template, the corresponding vertex $v'\in\Vpplus\bigcup\Vptimes$ is generated.
%   %     Finally, for each vertex \vi{i}$\in$$\V_S$, a two-step selection approach is applied as follows.



